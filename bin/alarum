#!/usr/bin/ruby

# 5. once we've sent an alert, should we subdue the alerting somehow
#  so we're not repeating the alert every iteration?
# 5.5 if we could reply 'shut up'/'ack' to the xmpp, that would be extra cool
# 6. find out why our tls connect is failing.  maybe it's certificates
# 7 we're not doing graphs yet
# 8. reload config on SIGHUP
# 9. why do we show as offline?
# 10. figure out how/where to build for simply puppet install

require 'errand'
require 'xmpp4r'
require 'yaml'

require 'alarum/jabber_connection'

$config = YAML.load_file("alarum.yml")

$jabber ||= Alarum::JabberConnection.new_from_yaml($config['configuration']['xmpp'])

# I'm grateful to Array#zip for existing, but not for its syntax
def zipmany(arrays)
  frst,*rst = arrays
  frst.zip(*rst)
end

def run_each_database(key, config)
  rrd=Errand.new(filename: config['datafile'])
  now = Time.now.to_i
  config['limits'].each do |limit|
    data = rrd.fetch(start: Time.now.to_i - limit['interval'])[:data]
    zipped = zipmany(data.values)
    expr = limit['value']
    result_series = zipped.map {|vals|
      if vals.any?(&:nan?)
        nil
      else
        OpenStruct.new(Hash[data.keys.zip(vals)]).instance_eval(expr)
      end
    }
    av = result_series.compact.reduce(:+) / result_series.length
    l = limit['exceeding']
    rcpt = limit['alert']
    if av > l then
      $jabber.alert rcpt, "#{key} #{expr} value #{av.to_i} exceeded limit #{l} over #{limit['interval']} seconds"
    else
      warn [Time.now,
            "#{key} #{expr} value #{av.to_i} inside limit #{l} over #{limit['interval']} seconds"]
    end
  end
end

all_recipients = $config['database'].values.flat_map{|d|
  d['limits'].map{|l| l['alert']}
}.uniq

all_recipients.each do |r|
  $jabber.alert r, "restarted #{$0} on #{Socket.gethostname}"
end

END {
  all_recipients.each do |r|
    $jabber.alert r, "#{$0} stopped on #{Socket.gethostname}: #{$!}"
  end
}

while true
  $config['database'].each do |key, db|
    run_each_database(key, db)
  end
  sleep 60
end
